## 6. 模块

使用Python解释器以交互模式进行程序设计，不便于保存程序数据。因此，编写程序时，最好使用文本编辑器先编写好，然后再运行这个文件。这就是所谓的"**脚本**"。随着程序变长，最后将其分成几个文件，这样更易于维护。另外，若要在其他程序中使用已编写好的函数，不需要把函数拷贝到每个程序中。

为实现该功能，Python提供了一种办法：把定义的函数放到一个文件中，然后在脚本或者交互方式中调用，这种文件称之为**模块**；模块中的定义可以导入其他模块或主模块中。

模块是包含python定义和声明的文件。文件名就是模块名加`.py`后缀。在模块里，模块的名字可以由全局变量`__name__`的值得到。例如，用你喜欢的文件编辑器在当前目录下创建一个名为`fibo.py`的文件，其内容如下：

```python
# Fibonacci numbers module

def fib(n):    # print Fibonacci series up to n
    a, b = 0, 1
    while b < n:
        print(b, end=' ')
        a, b = b, a+b
    print()

def fib2(n): # return Fibonacci series up to n
    result = []
    a, b = 0, 1
    while b < n:
        result.append(b)
        a, b = b, a+b
    return result
```

现在可以在别的程序中调用该模块：

```python
import fibo
fibo.fib(1000)
fibo.fib2(100)
fibo.__name__
## 'fibo'
```

如打算频繁使用该函数，可以赋给它一个本地的变量：
```python
fib = fibo.fib
fib(500)
```

### 6.1 深入模块
模块可以包含可执行语句以及函数的定义。这些语句通常用于初始化模块。它们只在**第一次** 导入时执行。[^1]（如果文件以脚本的方式执行，它们也会运行。）

每个模块都有自己的私有符号表，模块内定义的所有函数用其作为全局符号表。因此，模块的作者可以在模块里使用全局变量，而不用担心与某个用户的全局变量有冲突。另一方面，如果你知道自己在做什么，你可以使用引用模块函数的表示法访问模块的全局变量，`modname.itemname`。

模块中可以导入其它模块。习惯上将所有的 `import` 语句放在模块（或者脚本）的开始，但这不是强制性的。被导入的模块的名字放在导入模块的全局符号表中。

`import` 语句的一个变体直接从被导入的模块中导入名字到模块的符号表中。例如：

```Python
from fibo import fib, fib2
fib(500)
```

这不会吧模块名导入到本地符号表中。

还有一种方式可以导入模块中定义的多有名字：

```python
from fibo import *
fib(500)
```

这种方式不会导入以下划线`_`开头的名称。大多情况下，python程序员不会使用这个便利的方法，因为它会引入一系列未知的名称到解释器中，这很可能隐藏你定义的一些东西。

> 注意：一般情况下，不赞成从一个模块或包中导入`*`，因为这通常会导致代码很难读。不过，在交互式会话中是可以这样用的，它可以让你少敲一些代码。

+ 注意：处于性能考虑，每个模块在每个解释器会话中只导入一遍，因此，如果你修改了你的模块，你必须重启解释器。或者，如果你就是想交互式地测试一下模块，可以使用`imp.reload()`，例如`import imp; imp.reload(modulename)`。

#### 6.1.1 执行模块

当你用下面的方式运行一个python模块
```python
python fibo.py <arguments>
```

模块中的代码将会被执行，就行导入它一样，不过此时`__name__`被设置为"`__main__`"。也就是说，如果你在模块后加入以下代码：

```python
if __name__ == "__main__":
		import sys
		fib(int(sys.argv[1]))
```
就可以让此文件既可以作为可执行脚本，也可以作为导入的模块，因为解析命令行的那部分代码只有在模块作为“main”文件时才被调用：
```bash
$ python fibo.py 50
## 1 1 2 3 5 8 13 21 34
```

如果模块是被导入的，将不会运行这段代码：
```python
import fibo
```

#### 6.1.2 模块搜索路径

当导入一个名为spam的模块时，解释器首先搜索具有改名称的内置模块。如没有找到，它会接着到`sys.path`变量给出的目录中查找名为`spam.py`的文件。`sys.path`变量的初始值来自这些位置：

+ 脚本所在的目录（如未指明文件，则为当前目录）
+ `PYTHONPATH`（一个包含目录名的列表，与shell变量PATH的语法相同）
+ 与安装相关的默认值。

> Note: 
在支持符号连接的文件系统中，输入的脚本所在的目录是符号连接指向的目录。 换句话说也就是包含符号链接的目录不会被加到目录搜索路径中。 

初始化后，Python程序可以修改`sys.path`。脚本所在的目录被放置在搜索路径的最开始，也就是在标准库的路径之前，这意味着将会加载当前目录中的脚本，库目录中具有相同名称的模块不会被加载。除非有意替换标准库，否则这应被当作一个错误。更多消息参阅[标准模块](http://python.usyiyi.cn/python_343/tutorial/modules.html#tut-standardmodules)小节。

#### 6.1.3 “编译过的”python文件

为了加快加载模块的速度，Python会在`__pycache__`目录下以`module.version.pyc`名字缓存每个模块编译后的版本，这里的版本编制了编译后文件的格式。它通常会包含python的版本号。例如，在CPython3.3中，`spam.py`编译后的版本将缓存为`__pycache__/spam.cpython-33.pyc`。这种命名约定允许由不同发布和不同版本的python编译的模块同时存在。

Python会检查源文件与编译版的修改日期以确定它是否过期并需要重新编译。这是完全自动化的过程。同时，编译后的模块是跨平台的，所以同一个库可以在不同架构的系统之间共享。

Python 不检查在两个不同环境中的缓存。首先，它总会重新编译并且不会存储从命令行直接加载的模块。其次，如果没有源模块它不会检查缓存。若要支持没有源文件（只有编译版）的发布，编译后的模块必须在源目录下，并且必须没有源文件的模块。

部分高级技巧：

+ {{s.58}}{{s.59}}{{s.60}}{{s.61}}{{s.62}}

+  {{s.63}}{{s.64}}{{s.65}}

+  {{s.66}}{{s.67}}

+  {{s.68}}{{s.69}}{{s.70}}

+  {{s.71}}{{条例}}

+  {{}} s.73

### 6.2 标准模块


