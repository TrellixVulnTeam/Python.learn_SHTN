## 6. 模块

使用Python解释器以交互模式进行程序设计，不便于保存程序数据。因此，编写程序时，最好使用文本编辑器先编写好，然后再运行这个文件。这就是所谓的"**脚本**"。随着程序变长，最后将其分成几个文件，这样更易于维护。另外，若要在其他程序中使用已编写好的函数，不需要把函数拷贝到每个程序中。

为实现该功能，Python提供了一种办法：把定义的函数放到一个文件中，然后在脚本或者交互方式中调用，这种文件称之为**模块**；模块中的定义可以导入其他模块或主模块中。

模块是包含python定义和声明的文件。文件名就是模块名加`.py`后缀。在模块里，模块的名字可以由全局变量`__name__`的值得到。例如，用你喜欢的文件编辑器在当前目录下创建一个名为`fibo.py`的文件，其内容如下：

```python
# Fibonacci numbers module

def fib(n):    # print Fibonacci series up to n
    a, b = 0, 1
    while b < n:
        print(b, end=' ')
        a, b = b, a+b
    print()

def fib2(n): # return Fibonacci series up to n
    result = []
    a, b = 0, 1
    while b < n:
        result.append(b)
        a, b = b, a+b
    return result
```

现在可以在别的程序中调用该模块：

```python
import fibo
fibo.fib(1000)
fibo.fib2(100)
fibo.__name__
## 'fibo'
```

如打算频繁使用该函数，可以赋给它一个本地的变量：
```python
fib = fibo.fib
fib(500)
```

### 6.1 深入模块
模块可以包含可执行语句以及函数的定义。这些语句通常用于初始化模块。它们只在**第一次** 导入时执行。[^1]（如果文件以脚本的方式执行，它们也会运行。）

每个模块都有自己的私有符号表，模块内定义的所有函数用其作为全局符号表。因此，模块的作者可以在模块里使用全局变量，而不用担心与某个用户的全局变量有冲突。另一方面，如果你知道自己在做什么，你可以使用引用模块函数的表示法访问模块的全局变量，`modname.itemname`。

模块中可以导入其它模块。习惯上将所有的 `import` 语句放在模块（或者脚本）的开始，但这不是强制性的。被导入的模块的名字放在导入模块的全局符号表中。

`import` 语句的一个变体直接从被导入的模块中导入名字到模块的符号表中。例如：

```Python
from fibo import fib, fib2
fib(500)
```

这不会吧模块名导入到本地符号表中。

还有一种方式可以导入模块中定义的多有名字：

```python
from fibo import *
fib(500)
```

这种方式不会导入以下划线`_`开头的名称。大多情况下，python程序员不会使用这个便利的方法，因为它会引入一系列未知的名称到解释器中，这很可能隐藏你定义的一些东西。

> 注意：一般情况下，不赞成从一个模块或包中导入`*`，因为这通常会导致代码很难读。不过，在交互式会话中是可以这样用的，它可以让你少敲一些代码。

+ 注意：处于性能考虑，每个模块在每个解释器会话中只导入一遍，因此，如果你修改了你的模块，你必须重启解释器。或者，如果你就是想交互式地测试一下模块，可以使用`imp.reload()`，例如`import imp; imp.reload(modulename)`。

#### 6.1.1 执行模块

当你用下面的方式运行一个python模块
```python
python fibo.py <arguments>
```

模块中的代码将会被执行，就行导入它一样，不过此时`__name__`被设置为"`__main__`"。也就是说，如果你在模块后加入以下代码：

```python
if __name__ == "__main__":
		import sys
		fib(int(sys.argv[1]))
```
就可以让此文件既可以作为可执行脚本，也可以作为导入的模块，因为解析命令行的那部分代码只有在模块作为“main”文件时才被调用：
```bash
$ python fibo.py 50
## 1 1 2 3 5 8 13 21 34
```

如果模块是被导入的，将不会运行这段代码：
```python
import fibo
```

#### 6.1.2 模块搜索路径

当导入一个名为spam的模块时，解释器首先搜索具有改名称的内置模块。如没有找到，它会接着到`sys.path`变量给出的目录中查找名为`spam.py`的文件。`sys.path`变量的初始值来自这些位置：

+ 脚本所在的目录（如未指明文件，则为当前目录）
+ `PYTHONPATH`（一个包含目录名的列表，与shell变量PATH的语法相同）
+ 与安装相关的默认值。

> Note: 
在支持符号连接的文件系统中，输入的脚本所在的目录是符号连接指向的目录。 换句话说也就是包含符号链接的目录不会被加到目录搜索路径中。 



